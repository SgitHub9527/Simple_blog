import {
  computed,
  getCurrentInstance,
  init_vue_runtime_esm_bundler,
  inject,
  onBeforeMount,
  onBeforeUnmount,
  onMounted,
  reactive,
  readonly,
  ref,
  watch
} from "./chunk-2AMRO52V.js";
import {
  __esm,
  __export
} from "./chunk-J43GMYXM.js";

// node_modules/vooks/es/utils.js
function hasInstance() {
  return getCurrentInstance() !== null;
}
var isBrowser;
var init_utils = __esm({
  "node_modules/vooks/es/utils.js"() {
    init_vue_runtime_esm_bundler();
    isBrowser = typeof window !== "undefined";
  }
});

// node_modules/vooks/es/use-os-theme.js
function handleDarkMqlChange(e) {
  if (e.matches) {
    osTheme.value = "dark";
  }
}
function handleLightMqlChange(e) {
  if (e.matches) {
    osTheme.value = "light";
  }
}
function init() {
  darkMql = window.matchMedia("(prefers-color-scheme: dark)");
  lightMql = window.matchMedia("(prefers-color-scheme: light)");
  if (darkMql.matches) {
    osTheme.value = "dark";
  } else if (lightMql.matches) {
    osTheme.value = "light";
  } else {
    osTheme.value = null;
  }
  if (darkMql.addEventListener) {
    darkMql.addEventListener("change", handleDarkMqlChange);
    lightMql.addEventListener("change", handleLightMqlChange);
  } else if (darkMql.addListener) {
    darkMql.addListener(handleDarkMqlChange);
    lightMql.addListener(handleLightMqlChange);
  }
}
function clean() {
  if ("removeEventListener" in darkMql) {
    darkMql.removeEventListener("change", handleDarkMqlChange);
    lightMql.removeEventListener("change", handleLightMqlChange);
  } else if ("removeListener" in darkMql) {
    darkMql.removeListener(handleDarkMqlChange);
    lightMql.removeListener(handleLightMqlChange);
  }
  darkMql = void 0;
  lightMql = void 0;
}
function useOsTheme() {
  if (!supportMatchMedia) {
    return readonly(osTheme);
  }
  if (false) {
    return readonly(osTheme);
  }
  if (usedCount === 0)
    init();
  if (managable && (managable = hasInstance())) {
    onBeforeMount(() => {
      usedCount += 1;
    });
    onBeforeUnmount(() => {
      usedCount -= 1;
      if (usedCount === 0)
        clean();
    });
  }
  return readonly(osTheme);
}
var usedCount, supportMatchMedia, osTheme, darkMql, lightMql, managable;
var init_use_os_theme = __esm({
  "node_modules/vooks/es/use-os-theme.js"() {
    init_vue_runtime_esm_bundler();
    init_utils();
    usedCount = 0;
    supportMatchMedia = typeof window !== "undefined" && window.matchMedia !== void 0;
    osTheme = ref(null);
    managable = true;
  }
});

// node_modules/vooks/es/use-false-until-truthy.js
function useFalseUntilTruthy(originalRef) {
  const currentRef = ref(!!originalRef.value);
  if (currentRef.value)
    return readonly(currentRef);
  const stop = watch(originalRef, (value) => {
    if (value) {
      currentRef.value = true;
      stop();
    }
  });
  return readonly(currentRef);
}
var init_use_false_until_truthy = __esm({
  "node_modules/vooks/es/use-false-until-truthy.js"() {
    init_vue_runtime_esm_bundler();
  }
});

// node_modules/vooks/es/use-memo.js
function useMemo(getterOrOptions) {
  const computedValueRef = computed(getterOrOptions);
  const valueRef = ref(computedValueRef.value);
  watch(computedValueRef, (value) => {
    valueRef.value = value;
  });
  if (typeof getterOrOptions === "function") {
    return valueRef;
  } else {
    return {
      __v_isRef: true,
      get value() {
        return valueRef.value;
      },
      set value(v) {
        getterOrOptions.set(v);
      }
    };
  }
}
var use_memo_default;
var init_use_memo = __esm({
  "node_modules/vooks/es/use-memo.js"() {
    init_vue_runtime_esm_bundler();
    use_memo_default = useMemo;
  }
});

// node_modules/vooks/es/on-fonts-ready.js
function onFontsReady(cb) {
  if (isFontReady)
    return;
  let deactivated = false;
  onMounted(() => {
    if (!isFontReady) {
      fontsReady === null || fontsReady === void 0 ? void 0 : fontsReady.then(() => {
        if (deactivated)
          return;
        cb();
      });
    }
  });
  onBeforeUnmount(() => {
    deactivated = true;
  });
}
var fontsReady, isFontReady, init2;
var init_on_fonts_ready = __esm({
  "node_modules/vooks/es/on-fonts-ready.js"() {
    init_vue_runtime_esm_bundler();
    init_utils();
    init2 = () => {
      var _a, _b;
      fontsReady = isBrowser ? (_b = (_a = document) === null || _a === void 0 ? void 0 : _a.fonts) === null || _b === void 0 ? void 0 : _b.ready : void 0;
      isFontReady = false;
      if (fontsReady !== void 0) {
        void fontsReady.then(() => {
          isFontReady = true;
        });
      } else {
        isFontReady = true;
      }
    };
    init2();
  }
});

// node_modules/evtd/es/utils.js
function getEventTarget(e) {
  const path = e.composedPath();
  return path[0];
}
var init_utils2 = __esm({
  "node_modules/evtd/es/utils.js"() {
  }
});

// node_modules/evtd/es/traps.js
function createTrapHandler(name, el, originalHandler) {
  if (name === "mousemoveoutside") {
    const moveHandler = (e) => {
      if (el.contains(getEventTarget(e)))
        return;
      originalHandler(e);
    };
    return {
      mousemove: moveHandler,
      touchstart: moveHandler
    };
  } else if (name === "clickoutside") {
    let mouseDownOutside = false;
    const downHandler = (e) => {
      mouseDownOutside = !el.contains(getEventTarget(e));
    };
    const upHanlder = (e) => {
      if (!mouseDownOutside)
        return;
      if (el.contains(getEventTarget(e)))
        return;
      originalHandler(e);
    };
    return {
      mousedown: downHandler,
      mouseup: upHanlder,
      touchstart: downHandler,
      touchend: upHanlder
    };
  }
  console.error(
    `[evtd/create-trap-handler]: name \`${name}\` is invalid. This could be a bug of evtd.`
  );
  return {};
}
function ensureTrapHandlers(name, el, handler) {
  const handlers = traps[name];
  let elHandlers = handlers.get(el);
  if (elHandlers === void 0) {
    handlers.set(el, elHandlers = /* @__PURE__ */ new WeakMap());
  }
  let trapHandler = elHandlers.get(handler);
  if (trapHandler === void 0) {
    elHandlers.set(handler, trapHandler = createTrapHandler(name, el, handler));
  }
  return trapHandler;
}
function trapOn(name, el, handler, options) {
  if (name === "mousemoveoutside" || name === "clickoutside") {
    const trapHandlers = ensureTrapHandlers(name, el, handler);
    Object.keys(trapHandlers).forEach((key) => {
      on(key, document, trapHandlers[key], options);
    });
    return true;
  }
  return false;
}
function trapOff(name, el, handler, options) {
  if (name === "mousemoveoutside" || name === "clickoutside") {
    const trapHandlers = ensureTrapHandlers(name, el, handler);
    Object.keys(trapHandlers).forEach((key) => {
      off(key, document, trapHandlers[key], options);
    });
    return true;
  }
  return false;
}
var traps;
var init_traps = __esm({
  "node_modules/evtd/es/traps.js"() {
    init_delegate();
    init_utils2();
    traps = {
      mousemoveoutside: /* @__PURE__ */ new WeakMap(),
      clickoutside: /* @__PURE__ */ new WeakMap()
    };
  }
});

// node_modules/evtd/es/delegate.js
function createDelegate() {
  if (typeof window === "undefined") {
    return {
      on: () => {
      },
      off: () => {
      }
    };
  }
  const propagationStopped = /* @__PURE__ */ new WeakMap();
  const immediatePropagationStopped = /* @__PURE__ */ new WeakMap();
  function trackPropagation() {
    propagationStopped.set(this, true);
  }
  function trackImmediate() {
    propagationStopped.set(this, true);
    immediatePropagationStopped.set(this, true);
  }
  function spy(event, propName, fn) {
    const source = event[propName];
    event[propName] = function() {
      fn.apply(event, arguments);
      return source.apply(event, arguments);
    };
    return event;
  }
  function unspy(event, propName) {
    event[propName] = Event.prototype[propName];
  }
  const currentTargets = /* @__PURE__ */ new WeakMap();
  const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, "currentTarget");
  function getCurrentTarget() {
    var _a;
    return (_a = currentTargets.get(this)) !== null && _a !== void 0 ? _a : null;
  }
  function defineCurrentTarget(event, getter) {
    if (currentTargetDescriptor === void 0)
      return;
    Object.defineProperty(event, "currentTarget", {
      configurable: true,
      enumerable: true,
      get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get
    });
  }
  const phaseToTypeToElToHandlers = {
    bubble: {},
    capture: {}
  };
  const typeToWindowEventHandlers = {};
  function createUnifiedHandler() {
    const delegeteHandler = function(e) {
      const { type, eventPhase, bubbles } = e;
      const target = getEventTarget(e);
      if (eventPhase === 2)
        return;
      const phase = eventPhase === 1 ? "capture" : "bubble";
      let cursor = target;
      const path = [];
      while (true) {
        if (cursor === null)
          cursor = window;
        path.push(cursor);
        if (cursor === window) {
          break;
        }
        cursor = cursor.parentNode || null;
      }
      const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];
      const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];
      spy(e, "stopPropagation", trackPropagation);
      spy(e, "stopImmediatePropagation", trackImmediate);
      defineCurrentTarget(e, getCurrentTarget);
      if (phase === "capture") {
        if (captureElToHandlers === void 0)
          return;
        for (let i = path.length - 1; i >= 0; --i) {
          if (propagationStopped.has(e))
            break;
          const target2 = path[i];
          const handlers = captureElToHandlers.get(target2);
          if (handlers !== void 0) {
            currentTargets.set(e, target2);
            for (const handler of handlers) {
              if (immediatePropagationStopped.has(e))
                break;
              handler(e);
            }
          }
          if (i === 0 && !bubbles && bubbleElToHandlers !== void 0) {
            const bubbleHandlers = bubbleElToHandlers.get(target2);
            if (bubbleHandlers !== void 0) {
              for (const handler of bubbleHandlers) {
                if (immediatePropagationStopped.has(e))
                  break;
                handler(e);
              }
            }
          }
        }
      } else if (phase === "bubble") {
        if (bubbleElToHandlers === void 0)
          return;
        for (let i = 0; i < path.length; ++i) {
          if (propagationStopped.has(e))
            break;
          const target2 = path[i];
          const handlers = bubbleElToHandlers.get(target2);
          if (handlers !== void 0) {
            currentTargets.set(e, target2);
            for (const handler of handlers) {
              if (immediatePropagationStopped.has(e))
                break;
              handler(e);
            }
          }
        }
      }
      unspy(e, "stopPropagation");
      unspy(e, "stopImmediatePropagation");
      defineCurrentTarget(e);
    };
    delegeteHandler.displayName = "evtdUnifiedHandler";
    return delegeteHandler;
  }
  function createUnifiedWindowEventHandler() {
    const delegateHandler = function(e) {
      const { type, eventPhase } = e;
      if (eventPhase !== 2)
        return;
      const handlers = typeToWindowEventHandlers[type];
      if (handlers === void 0)
        return;
      handlers.forEach((handler) => handler(e));
    };
    delegateHandler.displayName = "evtdUnifiedWindowEventHandler";
    return delegateHandler;
  }
  const unifiedHandler = createUnifiedHandler();
  const unfiendWindowEventHandler = createUnifiedWindowEventHandler();
  function ensureElToHandlers(phase, type) {
    const phaseHandlers = phaseToTypeToElToHandlers[phase];
    if (phaseHandlers[type] === void 0) {
      phaseHandlers[type] = /* @__PURE__ */ new Map();
      window.addEventListener(type, unifiedHandler, phase === "capture");
    }
    return phaseHandlers[type];
  }
  function ensureWindowEventHandlers(type) {
    const windowEventHandlers = typeToWindowEventHandlers[type];
    if (windowEventHandlers === void 0) {
      typeToWindowEventHandlers[type] = /* @__PURE__ */ new Set();
      window.addEventListener(type, unfiendWindowEventHandler);
    }
    return typeToWindowEventHandlers[type];
  }
  function ensureHandlers(elToHandlers, el) {
    let elHandlers = elToHandlers.get(el);
    if (elHandlers === void 0) {
      elToHandlers.set(el, elHandlers = /* @__PURE__ */ new Set());
    }
    return elHandlers;
  }
  function handlerExist(el, phase, type, handler) {
    const elToHandlers = phaseToTypeToElToHandlers[phase][type];
    if (elToHandlers !== void 0) {
      const handlers = elToHandlers.get(el);
      if (handlers !== void 0) {
        if (handlers.has(handler))
          return true;
      }
    }
    return false;
  }
  function windowEventHandlerExist(type, handler) {
    const handlers = typeToWindowEventHandlers[type];
    if (handlers !== void 0) {
      if (handlers.has(handler)) {
        return true;
      }
    }
    return false;
  }
  function on2(type, el, handler, options) {
    let mergedHandler;
    if (typeof options === "object" && options.once === true) {
      mergedHandler = (e) => {
        off2(type, el, mergedHandler, options);
        handler(e);
      };
    } else {
      mergedHandler = handler;
    }
    const trapped = trapOn(type, el, mergedHandler, options);
    if (trapped)
      return;
    const phase = options === true || typeof options === "object" && options.capture === true ? "capture" : "bubble";
    const elToHandlers = ensureElToHandlers(phase, type);
    const handlers = ensureHandlers(elToHandlers, el);
    if (!handlers.has(mergedHandler))
      handlers.add(mergedHandler);
    if (el === window) {
      const windowEventHandlers = ensureWindowEventHandlers(type);
      if (!windowEventHandlers.has(mergedHandler)) {
        windowEventHandlers.add(mergedHandler);
      }
    }
  }
  function off2(type, el, handler, options) {
    const trapped = trapOff(type, el, handler, options);
    if (trapped)
      return;
    const capture = options === true || typeof options === "object" && options.capture === true;
    const phase = capture ? "capture" : "bubble";
    const elToHandlers = ensureElToHandlers(phase, type);
    const handlers = ensureHandlers(elToHandlers, el);
    if (el === window) {
      const mirrorPhase = capture ? "bubble" : "capture";
      if (!handlerExist(el, mirrorPhase, type, handler) && windowEventHandlerExist(type, handler)) {
        const windowEventHandlers = typeToWindowEventHandlers[type];
        windowEventHandlers.delete(handler);
        if (windowEventHandlers.size === 0) {
          window.removeEventListener(type, unfiendWindowEventHandler);
          typeToWindowEventHandlers[type] = void 0;
        }
      }
    }
    if (handlers.has(handler))
      handlers.delete(handler);
    if (handlers.size === 0) {
      elToHandlers.delete(el);
    }
    if (elToHandlers.size === 0) {
      window.removeEventListener(type, unifiedHandler, phase === "capture");
      phaseToTypeToElToHandlers[phase][type] = void 0;
    }
  }
  return {
    on: on2,
    off: off2
  };
}
var on, off;
var init_delegate = __esm({
  "node_modules/evtd/es/delegate.js"() {
    init_traps();
    init_utils2();
    ({ on, off } = createDelegate());
  }
});

// node_modules/evtd/es/index.js
var init_es = __esm({
  "node_modules/evtd/es/index.js"() {
    init_delegate();
  }
});

// node_modules/vooks/es/use-click-position.js
function clickHandler(e) {
  if (e.clientX > 0 || e.clientY > 0) {
    mousePositionRef.value = {
      x: e.clientX,
      y: e.clientY
    };
  } else {
    const { target } = e;
    if (target instanceof Element) {
      const { left, top, width, height } = target.getBoundingClientRect();
      if (left > 0 || top > 0) {
        mousePositionRef.value = {
          x: left + width / 2,
          y: top + height / 2
        };
      } else {
        mousePositionRef.value = { x: 0, y: 0 };
      }
    } else {
      mousePositionRef.value = null;
    }
  }
}
function useClickPosition() {
  if (!isBrowser)
    return readonly(ref(null));
  if (usedCount2 === 0)
    on("click", document, clickHandler, true);
  const setup2 = () => {
    usedCount2 += 1;
  };
  if (managable2 && (managable2 = hasInstance())) {
    onBeforeMount(setup2);
    onBeforeUnmount(() => {
      usedCount2 -= 1;
      if (usedCount2 === 0)
        off("click", document, clickHandler, true);
    });
  } else {
    setup2();
  }
  return readonly(mousePositionRef);
}
var mousePositionRef, usedCount2, managable2;
var init_use_click_position = __esm({
  "node_modules/vooks/es/use-click-position.js"() {
    init_vue_runtime_esm_bundler();
    init_es();
    init_utils();
    mousePositionRef = ref(null);
    usedCount2 = 0;
    managable2 = true;
  }
});

// node_modules/vooks/es/use-clicked.js
function handleClick() {
  clickedTimeRef.value = Date.now();
}
function useClicked(timeout) {
  if (!isBrowser)
    return readonly(ref(false));
  const clickedRef = ref(false);
  let timerId = null;
  function clearTimer() {
    if (timerId !== null)
      window.clearTimeout(timerId);
  }
  function clickedHandler() {
    clearTimer();
    clickedRef.value = true;
    timerId = window.setTimeout(() => {
      clickedRef.value = false;
    }, timeout);
  }
  if (usedCount3 === 0) {
    on("click", window, handleClick, true);
  }
  const setup2 = () => {
    usedCount3 += 1;
    on("click", window, clickedHandler, true);
  };
  if (managable3 && (managable3 = hasInstance())) {
    onBeforeMount(setup2);
    onBeforeUnmount(() => {
      usedCount3 -= 1;
      if (usedCount3 === 0) {
        off("click", window, handleClick, true);
      }
      off("click", window, clickedHandler, true);
      clearTimer();
    });
  } else {
    setup2();
  }
  return readonly(clickedRef);
}
var clickedTimeRef, usedCount3, managable3;
var init_use_clicked = __esm({
  "node_modules/vooks/es/use-clicked.js"() {
    init_vue_runtime_esm_bundler();
    init_es();
    init_utils();
    clickedTimeRef = ref(void 0);
    usedCount3 = 0;
    managable3 = true;
  }
});

// node_modules/vooks/es/use-merged-state.js
function useMergedState(controlledStateRef, uncontrolledStateRef) {
  watch(controlledStateRef, (value) => {
    if (value !== void 0) {
      uncontrolledStateRef.value = value;
    }
  });
  return computed(() => {
    if (controlledStateRef.value === void 0) {
      return uncontrolledStateRef.value;
    }
    return controlledStateRef.value;
  });
}
var init_use_merged_state = __esm({
  "node_modules/vooks/es/use-merged-state.js"() {
    init_vue_runtime_esm_bundler();
  }
});

// node_modules/vooks/es/life-cycle/use-is-mounted.js
function isMounted() {
  const isMounted2 = ref(false);
  onMounted(() => {
    isMounted2.value = true;
  });
  return readonly(isMounted2);
}
var init_use_is_mounted = __esm({
  "node_modules/vooks/es/life-cycle/use-is-mounted.js"() {
    init_vue_runtime_esm_bundler();
  }
});

// node_modules/vooks/es/use-compitable.js
function useCompitable(reactive2, keys) {
  return computed(() => {
    for (const key of keys) {
      if (reactive2[key] !== void 0)
        return reactive2[key];
    }
    return reactive2[keys[keys.length - 1]];
  });
}
var init_use_compitable = __esm({
  "node_modules/vooks/es/use-compitable.js"() {
    init_vue_runtime_esm_bundler();
  }
});

// node_modules/vooks/es/use-is-ios.js
function useIsIos() {
  return isIos;
}
var isIos;
var init_use_is_ios = __esm({
  "node_modules/vooks/es/use-is-ios.js"() {
    isIos = (typeof window === "undefined" ? false : /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && !window.MSStream;
  }
});

// node_modules/vooks/es/use-breakpoints.js
function createMediaQuery(screenWidth) {
  return `(min-width: ${screenWidth}px)`;
}
function useBreakpoints(screens = defaultBreakpointOptions) {
  if (!isBrowser)
    return computed(() => []);
  if (typeof window.matchMedia !== "function")
    return computed(() => []);
  const breakpointStatusRef = ref({});
  const breakpoints = Object.keys(screens);
  const updateBreakpoints = (e, breakpointName) => {
    if (e.matches)
      breakpointStatusRef.value[breakpointName] = true;
    else
      breakpointStatusRef.value[breakpointName] = false;
  };
  breakpoints.forEach((key) => {
    const breakpointValue = screens[key];
    let mql;
    let cbs2;
    if (mqlMap[breakpointValue] === void 0) {
      mql = window.matchMedia(createMediaQuery(breakpointValue));
      if (mql.addEventListener) {
        mql.addEventListener("change", (e) => {
          cbs2.forEach((cb) => {
            cb(e, key);
          });
        });
      } else if (mql.addListener) {
        mql.addListener((e) => {
          cbs2.forEach((cb) => {
            cb(e, key);
          });
        });
      }
      cbs2 = /* @__PURE__ */ new Set();
      mqlMap[breakpointValue] = {
        mql,
        cbs: cbs2
      };
    } else {
      mql = mqlMap[breakpointValue].mql;
      cbs2 = mqlMap[breakpointValue].cbs;
    }
    cbs2.add(updateBreakpoints);
    if (mql.matches) {
      cbs2.forEach((cb) => {
        cb(mql, key);
      });
    }
  });
  onBeforeUnmount(() => {
    breakpoints.forEach((breakpoint) => {
      const { cbs: cbs2 } = mqlMap[screens[breakpoint]];
      if (cbs2.has(updateBreakpoints)) {
        cbs2.delete(updateBreakpoints);
      }
    });
  });
  return computed(() => {
    const { value } = breakpointStatusRef;
    return breakpoints.filter((key) => value[key]);
  });
}
var defaultBreakpointOptions, mqlMap, use_breakpoints_default;
var init_use_breakpoints = __esm({
  "node_modules/vooks/es/use-breakpoints.js"() {
    init_vue_runtime_esm_bundler();
    init_utils();
    defaultBreakpointOptions = {
      xs: 0,
      s: 640,
      m: 1024,
      l: 1280,
      xl: 1536,
      "2xl": 1920
    };
    mqlMap = {};
    use_breakpoints_default = useBreakpoints;
  }
});

// node_modules/vooks/es/use-breakpoint.js
function useBreakpoint(screens) {
  if (!isBrowser)
    return computed(() => void 0);
  const breakpointsRef = screens !== void 0 ? use_breakpoints_default(screens) : use_breakpoints_default();
  return computed(() => {
    const { value } = breakpointsRef;
    if (value.length === 0)
      return void 0;
    return value[value.length - 1];
  });
}
var use_breakpoint_default;
var init_use_breakpoint = __esm({
  "node_modules/vooks/es/use-breakpoint.js"() {
    init_vue_runtime_esm_bundler();
    init_use_breakpoints();
    init_utils();
    use_breakpoint_default = useBreakpoint;
  }
});

// node_modules/vooks/es/use-keyboard.js
function useKeyboard(options = {}, enabledRef) {
  const state = reactive({
    ctrl: false,
    command: false,
    win: false,
    shift: false,
    tab: false
  });
  const { keydown, keyup } = options;
  const keydownHandler = (e) => {
    switch (e.key) {
      case "Control":
        state.ctrl = true;
        break;
      case "Meta":
        state.command = true;
        state.win = true;
        break;
      case "Shift":
        state.shift = true;
        break;
      case "Tab":
        state.tab = true;
        break;
    }
    if (keydown !== void 0) {
      Object.keys(keydown).forEach((key) => {
        if (key !== e.key)
          return;
        const handler = keydown[key];
        if (typeof handler === "function") {
          handler(e);
        } else {
          const { stop = false, prevent = false } = handler;
          if (stop)
            e.stopPropagation();
          if (prevent)
            e.preventDefault();
          handler.handler(e);
        }
      });
    }
  };
  const keyupHandler = (e) => {
    switch (e.key) {
      case "Control":
        state.ctrl = false;
        break;
      case "Meta":
        state.command = false;
        state.win = false;
        break;
      case "Shift":
        state.shift = false;
        break;
      case "Tab":
        state.tab = false;
        break;
    }
    if (keyup !== void 0) {
      Object.keys(keyup).forEach((key) => {
        if (key !== e.key)
          return;
        const handler = keyup[key];
        if (typeof handler === "function") {
          handler(e);
        } else {
          const { stop = false, prevent = false } = handler;
          if (stop)
            e.stopPropagation();
          if (prevent)
            e.preventDefault();
          handler.handler(e);
        }
      });
    }
  };
  const setup2 = () => {
    if (enabledRef === void 0 || enabledRef.value) {
      on("keydown", document, keydownHandler);
      on("keyup", document, keyupHandler);
    }
    if (enabledRef !== void 0) {
      watch(enabledRef, (value) => {
        if (value) {
          on("keydown", document, keydownHandler);
          on("keyup", document, keyupHandler);
        } else {
          off("keydown", document, keydownHandler);
          off("keyup", document, keyupHandler);
        }
      });
    }
  };
  if (hasInstance()) {
    onBeforeMount(setup2);
    onBeforeUnmount(() => {
      if (enabledRef === void 0 || enabledRef.value) {
        off("keydown", document, keydownHandler);
        off("keyup", document, keyupHandler);
      }
    });
  } else {
    setup2();
  }
  return readonly(state);
}
var init_use_keyboard = __esm({
  "node_modules/vooks/es/use-keyboard.js"() {
    init_vue_runtime_esm_bundler();
    init_es();
    init_utils();
  }
});

// node_modules/vooks/es/use-is-safari.js
function useIsSafari() {
  return isSafari;
}
var isSafari;
var init_use_is_safari = __esm({
  "node_modules/vooks/es/use-is-safari.js"() {
    init_use_is_ios();
    isSafari = typeof window === "undefined" ? false : isIos || window.safari !== void 0;
  }
});

// node_modules/vooks/es/index.js
var es_exports = {};
__export(es_exports, {
  onFontsReady: () => onFontsReady,
  useBreakpoint: () => use_breakpoint_default,
  useBreakpoints: () => use_breakpoints_default,
  useClickPosition: () => useClickPosition,
  useClicked: () => useClicked,
  useCompitable: () => useCompitable,
  useFalseUntilTruthy: () => useFalseUntilTruthy,
  useIsIos: () => useIsIos,
  useIsMounted: () => isMounted,
  useIsSafari: () => useIsSafari,
  useKeyboard: () => useKeyboard,
  useMemo: () => use_memo_default,
  useMergedState: () => useMergedState,
  useOsTheme: () => useOsTheme
});
var init_es2 = __esm({
  "node_modules/vooks/es/index.js"() {
    init_use_false_until_truthy();
    init_use_memo();
    init_on_fonts_ready();
    init_use_click_position();
    init_use_clicked();
    init_use_os_theme();
    init_use_merged_state();
    init_use_is_mounted();
    init_use_compitable();
    init_use_is_ios();
    init_use_breakpoints();
    init_use_breakpoint();
    init_use_keyboard();
    init_use_is_safari();
  }
});

// node_modules/seemly/es/animation/next-frame-once.js
function flushOnceCallbacks() {
  onceCbs.forEach((cb) => cb(...paramsMap.get(cb)));
  onceCbs = [];
}
function beforeNextFrameOnce(cb, ...params2) {
  paramsMap.set(cb, params2);
  if (onceCbs.includes(cb))
    return;
  onceCbs.push(cb) === 1 && requestAnimationFrame(flushOnceCallbacks);
}
var onceCbs, paramsMap;
var init_next_frame_once = __esm({
  "node_modules/seemly/es/animation/next-frame-once.js"() {
    onceCbs = [];
    paramsMap = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/seemly/es/dom/get-scroll-parent.js
function getParentNode(node) {
  if (node.nodeType === 9) {
    return null;
  }
  return node.parentNode;
}
function getScrollParent(node) {
  if (node === null)
    return null;
  const parentNode = getParentNode(node);
  if (parentNode === null) {
    return null;
  }
  if (parentNode.nodeType === 9) {
    return document.documentElement;
  }
  if (parentNode.nodeType === 1) {
    const { overflow, overflowX, overflowY } = getComputedStyle(parentNode);
    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return parentNode;
    }
  }
  return getScrollParent(parentNode);
}
var init_get_scroll_parent = __esm({
  "node_modules/seemly/es/dom/get-scroll-parent.js"() {
  }
});

// node_modules/seemly/es/dom/unwrap-element.js
function unwrapElement(target) {
  if (typeof target === "string")
    return document.querySelector(target);
  if (typeof target === "function")
    return target();
  return target;
}
var init_unwrap_element = __esm({
  "node_modules/seemly/es/dom/unwrap-element.js"() {
  }
});

// node_modules/seemly/es/dom/happens-in.js
function happensIn(e, dataSetPropName) {
  let { target } = e;
  while (target) {
    if (target.dataset) {
      if (target.dataset[dataSetPropName] !== void 0)
        return true;
    }
    target = target.parentElement;
  }
  return false;
}
var init_happens_in = __esm({
  "node_modules/seemly/es/dom/happens-in.js"() {
  }
});

// node_modules/seemly/es/dom/get-precise-event-target.js
function getPreciseEventTarget(event) {
  return event.composedPath()[0] || null;
}
var init_get_precise_event_target = __esm({
  "node_modules/seemly/es/dom/get-precise-event-target.js"() {
  }
});

// node_modules/seemly/es/css/responsive.js
function parseResponsiveProp(reponsiveProp) {
  if (typeof reponsiveProp === "number") {
    return {
      "": reponsiveProp.toString()
    };
  }
  const params2 = {};
  reponsiveProp.split(/ +/).forEach((pairLiteral) => {
    if (pairLiteral === "")
      return;
    const [prefix2, value] = pairLiteral.split(":");
    if (value === void 0) {
      params2[""] = prefix2;
    } else {
      params2[prefix2] = value;
    }
  });
  return params2;
}
function parseResponsivePropValue(reponsiveProp, activeKeyOrSize) {
  var _a;
  if (reponsiveProp === void 0 || reponsiveProp === null)
    return void 0;
  const classObj = parseResponsiveProp(reponsiveProp);
  if (activeKeyOrSize === void 0)
    return classObj[""];
  if (typeof activeKeyOrSize === "string") {
    return (_a = classObj[activeKeyOrSize]) !== null && _a !== void 0 ? _a : classObj[""];
  } else if (Array.isArray(activeKeyOrSize)) {
    for (let i = activeKeyOrSize.length - 1; i >= 0; --i) {
      const key = activeKeyOrSize[i];
      if (key in classObj)
        return classObj[key];
    }
    return classObj[""];
  } else {
    let activeValue = void 0;
    let activeKey = -1;
    Object.keys(classObj).forEach((key) => {
      const keyAsNum = Number(key);
      if (!Number.isNaN(keyAsNum) && activeKeyOrSize >= keyAsNum && keyAsNum >= activeKey) {
        activeKey = keyAsNum;
        activeValue = classObj[key];
      }
    });
    return activeValue;
  }
}
var init_responsive = __esm({
  "node_modules/seemly/es/css/responsive.js"() {
  }
});

// node_modules/seemly/es/css/index.js
function depx(value) {
  if (typeof value === "string") {
    if (value.endsWith("px")) {
      return Number(value.slice(0, value.length - 2));
    }
    return Number(value);
  }
  return value;
}
function pxfy(value) {
  if (value === void 0 || value === null)
    return void 0;
  if (typeof value === "number")
    return `${value}px`;
  if (value.endsWith("px"))
    return value;
  return `${value}px`;
}
function getMargin(value, position) {
  const parts = value.trim().split(/\s+/g);
  const margin = {
    top: parts[0]
  };
  switch (parts.length) {
    case 1:
      margin.right = parts[0];
      margin.bottom = parts[0];
      margin.left = parts[0];
      break;
    case 2:
      margin.right = parts[1];
      margin.left = parts[1];
      margin.bottom = parts[0];
      break;
    case 3:
      margin.right = parts[1];
      margin.bottom = parts[2];
      margin.left = parts[1];
      break;
    case 4:
      margin.right = parts[1];
      margin.bottom = parts[2];
      margin.left = parts[3];
      break;
    default:
      throw new Error("[seemly/getMargin]:" + value + " is not a valid value.");
  }
  if (position === void 0)
    return margin;
  return margin[position];
}
function getGap(value, orient) {
  const [rowGap, colGap] = value.split(" ");
  if (!orient)
    return {
      row: rowGap,
      col: colGap || rowGap
    };
  return orient === "row" ? rowGap : colGap;
}
var init_css = __esm({
  "node_modules/seemly/es/css/index.js"() {
    init_responsive();
  }
});

// node_modules/seemly/es/color/convert.js
function hsl2hsv(h, s, l) {
  s /= 100;
  l /= 100;
  const v = s * Math.min(l, 1 - l) + l;
  return [h, v ? (2 - 2 * l / v) * 100 : 0, v * 100];
}
function hsv2hsl(h, s, v) {
  s /= 100;
  v /= 100;
  const l = v - v * s / 2;
  const m = Math.min(l, 1 - l);
  return [h, m ? (v - l) / m * 100 : 0, l * 100];
}
function hsv2rgb(h, s, v) {
  s /= 100;
  v /= 100;
  let f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5) * 255, f(3) * 255, f(1) * 255];
}
function rgb2hsv(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  let v = Math.max(r, g, b), c2 = v - Math.min(r, g, b);
  let h = c2 && (v == r ? (g - b) / c2 : v == g ? 2 + (b - r) / c2 : 4 + (r - g) / c2);
  return [60 * (h < 0 ? h + 6 : h), v && c2 / v * 100, v * 100];
}
function rgb2hsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  let v = Math.max(r, g, b), c2 = v - Math.min(r, g, b), f = 1 - Math.abs(v + v - c2 - 1);
  let h = c2 && (v == r ? (g - b) / c2 : v == g ? 2 + (b - r) / c2 : 4 + (r - g) / c2);
  return [60 * (h < 0 ? h + 6 : h), f ? c2 / f * 100 : 0, (v + v - c2) * 50];
}
function hsl2rgb(h, s, l) {
  s /= 100;
  l /= 100;
  let a = s * Math.min(l, 1 - l);
  let f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0) * 255, f(8) * 255, f(4) * 255];
}
var init_convert = __esm({
  "node_modules/seemly/es/color/convert.js"() {
  }
});

// node_modules/seemly/es/color/colors.js
var colors_default;
var init_colors = __esm({
  "node_modules/seemly/es/color/colors.js"() {
    colors_default = {
      black: "#000",
      silver: "#C0C0C0",
      gray: "#808080",
      white: "#FFF",
      maroon: "#800000",
      red: "#F00",
      purple: "#800080",
      fuchsia: "#F0F",
      green: "#008000",
      lime: "#0F0",
      olive: "#808000",
      yellow: "#FF0",
      navy: "#000080",
      blue: "#00F",
      teal: "#008080",
      aqua: "#0FF",
      transparent: "#0000"
    };
  }
});

// node_modules/seemly/es/color/index.js
function parseHex(value) {
  return parseInt(value, 16);
}
function hsla(color) {
  try {
    let i;
    if (i = hslaRegex.exec(color)) {
      return [
        roundDeg(i[1]),
        roundPercent(i[5]),
        roundPercent(i[9]),
        roundAlpha(i[13])
      ];
    } else if (i = hslRegex.exec(color)) {
      return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
    }
    throw new Error(`[seemly/hsla]: Invalid color value ${color}.`);
  } catch (e) {
    throw e;
  }
}
function hsva(color) {
  try {
    let i;
    if (i = hsvaRegex.exec(color)) {
      return [
        roundDeg(i[1]),
        roundPercent(i[5]),
        roundPercent(i[9]),
        roundAlpha(i[13])
      ];
    } else if (i = hsvRegex.exec(color)) {
      return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
    }
    throw new Error(`[seemly/hsva]: Invalid color value ${color}.`);
  } catch (e) {
    throw e;
  }
}
function rgba(color) {
  try {
    let i;
    if (i = hexRegex.exec(color)) {
      return [parseHex(i[1]), parseHex(i[2]), parseHex(i[3]), 1];
    } else if (i = rgbRegex.exec(color)) {
      return [roundChannel(i[1]), roundChannel(i[5]), roundChannel(i[9]), 1];
    } else if (i = rgbaRegex.exec(color)) {
      return [
        roundChannel(i[1]),
        roundChannel(i[5]),
        roundChannel(i[9]),
        roundAlpha(i[13])
      ];
    } else if (i = sHexRegex.exec(color)) {
      return [
        parseHex(i[1] + i[1]),
        parseHex(i[2] + i[2]),
        parseHex(i[3] + i[3]),
        1
      ];
    } else if (i = hexaRegex.exec(color)) {
      return [
        parseHex(i[1]),
        parseHex(i[2]),
        parseHex(i[3]),
        roundAlpha(parseHex(i[4]) / 255)
      ];
    } else if (i = sHexaRegex.exec(color)) {
      return [
        parseHex(i[1] + i[1]),
        parseHex(i[2] + i[2]),
        parseHex(i[3] + i[3]),
        roundAlpha(parseHex(i[4] + i[4]) / 255)
      ];
    } else if (color in colors_default) {
      return rgba(colors_default[color]);
    }
    throw new Error(`[seemly/rgba]: Invalid color value ${color}.`);
  } catch (e) {
    throw e;
  }
}
function normalizeAlpha(alphaValue) {
  return alphaValue > 1 ? 1 : alphaValue < 0 ? 0 : alphaValue;
}
function stringifyRgb(r, g, b) {
  return `rgb(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)})`;
}
function stringifyRgba(r, g, b, a) {
  return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${normalizeAlpha(a)})`;
}
function compositeChannel(v1, a1, v2, a2, a) {
  return roundChannel((v1 * a1 * (1 - a2) + v2 * a2) / a);
}
function composite(background, overlay) {
  if (!Array.isArray(background))
    background = rgba(background);
  if (!Array.isArray(overlay))
    overlay = rgba(overlay);
  const a1 = background[3];
  const a2 = overlay[3];
  const alpha = roundAlpha(a1 + a2 - a1 * a2);
  return stringifyRgba(compositeChannel(background[0], a1, overlay[0], a2, alpha), compositeChannel(background[1], a1, overlay[1], a2, alpha), compositeChannel(background[2], a1, overlay[2], a2, alpha), alpha);
}
function changeColor(base, options) {
  const [r, g, b, a = 1] = Array.isArray(base) ? base : rgba(base);
  if (options.alpha) {
    return stringifyRgba(r, g, b, options.alpha);
  }
  return stringifyRgba(r, g, b, a);
}
function scaleColor(base, options) {
  const [r, g, b, a = 1] = Array.isArray(base) ? base : rgba(base);
  const { lightness = 1, alpha = 1 } = options;
  return toRgbaString([r * lightness, g * lightness, b * lightness, a * alpha]);
}
function getAlpha(base) {
  var _a;
  const alpha = (_a = (Array.isArray(base) ? base : rgba(base))[3]) !== null && _a !== void 0 ? _a : 1;
  return alpha;
}
function getAlphaString(base) {
  return `${getAlpha(base)}`;
}
function roundAlpha(value) {
  const v = Math.round(Number(value) * 100) / 100;
  if (v > 1)
    return 1;
  if (v < 0)
    return 0;
  return v;
}
function roundDeg(value) {
  const v = Math.round(Number(value));
  if (v >= 360)
    return 0;
  if (v < 0)
    return 0;
  return v;
}
function roundChannel(value) {
  const v = Math.round(Number(value));
  if (v > 255)
    return 255;
  if (v < 0)
    return 0;
  return v;
}
function roundPercent(value) {
  const v = Math.round(Number(value));
  if (v > 100)
    return 100;
  if (v < 0)
    return 0;
  return v;
}
function toRgbString(base) {
  const [r, g, b] = Array.isArray(base) ? base : rgba(base);
  return stringifyRgb(r, g, b);
}
function toRgbaString(base) {
  const [r, g, b] = base;
  if (3 in base) {
    return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${roundAlpha(base[3])})`;
  }
  return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, 1)`;
}
function toHsvString(base) {
  return `hsv(${roundDeg(base[0])}, ${roundPercent(base[1])}%, ${roundPercent(base[2])}%)`;
}
function toHsvaString(base) {
  const [h, s, v] = base;
  if (3 in base) {
    return `hsva(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(v)}%, ${roundAlpha(base[3])})`;
  }
  return `hsva(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(v)}%, 1)`;
}
function toHslString(base) {
  return `hsl(${roundDeg(base[0])}, ${roundPercent(base[1])}%, ${roundPercent(base[2])}%)`;
}
function toHslaString(base) {
  const [h, s, l] = base;
  if (3 in base) {
    return `hsla(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(l)}%, ${roundAlpha(base[3])})`;
  }
  return `hsla(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(l)}%, 1)`;
}
function toHexaString(base) {
  if (typeof base === "string") {
    let i;
    if (i = hexRegex.exec(base)) {
      return `${i[0]}FF`;
    } else if (i = hexaRegex.exec(base)) {
      return i[0];
    } else if (i = sHexRegex.exec(base)) {
      return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}FF`;
    } else if (i = sHexaRegex.exec(base)) {
      return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}${i[4]}${i[4]}`;
    }
    throw new Error(`[seemly/toHexString]: Invalid hex value ${base}.`);
  }
  const hex2 = `#${base.slice(0, 3).map((unit) => roundChannel(unit).toString(16).toUpperCase().padStart(2, "0")).join("")}`;
  const a = base.length === 3 ? "FF" : roundChannel(base[3] * 255).toString(16).padStart(2, "0").toUpperCase();
  return hex2 + a;
}
function toHexString(base) {
  if (typeof base === "string") {
    let i;
    if (i = hexRegex.exec(base)) {
      return i[0];
    } else if (i = hexaRegex.exec(base)) {
      return i[0].slice(0, 7);
    } else if (i = sHexRegex.exec(base) || sHexaRegex.exec(base)) {
      return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}`;
    }
    throw new Error(`[seemly/toHexString]: Invalid hex value ${base}.`);
  }
  return `#${base.slice(0, 3).map((unit) => roundChannel(unit).toString(16).toUpperCase().padStart(2, "0")).join("")}`;
}
var prefix, suffix, percent, float, hex, dhex, hslRegex, hsvRegex, hslaRegex, hsvaRegex, rgbRegex, rgbaRegex, sHexRegex, hexRegex, sHexaRegex, hexaRegex;
var init_color = __esm({
  "node_modules/seemly/es/color/index.js"() {
    init_colors();
    init_convert();
    prefix = "^\\s*";
    suffix = "\\s*$";
    percent = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))%\\s*";
    float = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*";
    hex = "([0-9A-Fa-f])";
    dhex = "([0-9A-Fa-f]{2})";
    hslRegex = new RegExp(`${prefix}hsl\\s*\\(${float},${percent},${percent}\\)${suffix}`);
    hsvRegex = new RegExp(`${prefix}hsv\\s*\\(${float},${percent},${percent}\\)${suffix}`);
    hslaRegex = new RegExp(`${prefix}hsla\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
    hsvaRegex = new RegExp(`${prefix}hsva\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
    rgbRegex = new RegExp(`${prefix}rgb\\s*\\(${float},${float},${float}\\)${suffix}`);
    rgbaRegex = new RegExp(`${prefix}rgba\\s*\\(${float},${float},${float},${float}\\)${suffix}`);
    sHexRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${suffix}`);
    hexRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${suffix}`);
    sHexaRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${hex}${suffix}`);
    hexaRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${dhex}${suffix}`);
  }
});

// node_modules/seemly/es/misc/index.js
function createId(length = 8) {
  return Math.random().toString(16).slice(2, 2 + length);
}
function repeat(count, v) {
  const ret = [];
  for (let i = 0; i < count; ++i) {
    ret.push(v);
  }
  return ret;
}
function indexMap(count, createValue) {
  const ret = [];
  if (!createValue) {
    for (let i = 0; i < count; ++i) {
      ret.push(i);
    }
    return ret;
  }
  for (let i = 0; i < count; ++i) {
    ret.push(createValue(i));
  }
  return ret;
}
async function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
var init_misc = __esm({
  "node_modules/seemly/es/misc/index.js"() {
  }
});

// node_modules/seemly/es/animation/next-frame.js
function flushCallbacks() {
  cbs.forEach((cb, i) => cb(...params[i]));
  cbs = [];
  params = [];
}
function beforeNextFrame(cb, ...args) {
  cbs.push(cb) === 1 && requestAnimationFrame(flushCallbacks);
  params.push(args);
}
var cbs, params;
var init_next_frame = __esm({
  "node_modules/seemly/es/animation/next-frame.js"() {
    cbs = [];
    params = [];
  }
});

// node_modules/seemly/es/index.js
var es_exports2 = {};
__export(es_exports2, {
  beforeNextFrame: () => beforeNextFrame,
  beforeNextFrameOnce: () => beforeNextFrameOnce,
  changeColor: () => changeColor,
  composite: () => composite,
  createId: () => createId,
  depx: () => depx,
  getAlpha: () => getAlpha,
  getAlphaString: () => getAlphaString,
  getGap: () => getGap,
  getMargin: () => getMargin,
  getPadding: () => getMargin,
  getPreciseEventTarget: () => getPreciseEventTarget,
  getScrollParent: () => getScrollParent,
  happensIn: () => happensIn,
  hsl2hsv: () => hsl2hsv,
  hsl2rgb: () => hsl2rgb,
  hsla: () => hsla,
  hsv2hsl: () => hsv2hsl,
  hsv2rgb: () => hsv2rgb,
  hsva: () => hsva,
  indexMap: () => indexMap,
  parseResponsiveProp: () => parseResponsiveProp,
  parseResponsivePropValue: () => parseResponsivePropValue,
  pxfy: () => pxfy,
  repeat: () => repeat,
  rgb2hsl: () => rgb2hsl,
  rgb2hsv: () => rgb2hsv,
  rgba: () => rgba,
  roundAlpha: () => roundAlpha,
  roundChannel: () => roundChannel,
  roundDeg: () => roundDeg,
  roundPercent: () => roundPercent,
  scaleColor: () => scaleColor,
  sleep: () => sleep,
  toHexString: () => toHexString,
  toHexaString: () => toHexaString,
  toHslString: () => toHslString,
  toHslaString: () => toHslaString,
  toHsvString: () => toHsvString,
  toHsvaString: () => toHsvaString,
  toRgbString: () => toRgbString,
  toRgbaString: () => toRgbaString,
  unwrapElement: () => unwrapElement
});
var init_es3 = __esm({
  "node_modules/seemly/es/index.js"() {
    init_next_frame_once();
    init_next_frame();
    init_get_scroll_parent();
    init_unwrap_element();
    init_happens_in();
    init_get_precise_event_target();
    init_css();
    init_color();
    init_misc();
  }
});

// node_modules/@emotion/hash/dist/hash.browser.esm.js
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= k >>> 24;
    h = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}
var hash_browser_esm_default;
var init_hash_browser_esm = __esm({
  "node_modules/@emotion/hash/dist/hash.browser.esm.js"() {
    hash_browser_esm_default = murmur2;
  }
});

// node_modules/css-render/esm/hash.js
var init_hash = __esm({
  "node_modules/css-render/esm/hash.js"() {
    init_hash_browser_esm();
  }
});

// node_modules/css-render/esm/parse.js
function ampCount(selector) {
  let cnt = 0;
  for (let i = 0; i < selector.length; ++i) {
    if (selector[i] === "&")
      ++cnt;
  }
  return cnt;
}
function resolveSelectorWithAmp(amp, selector) {
  const nextAmp = [];
  selector.split(separatorRegex).forEach((partialSelector) => {
    let round = ampCount(partialSelector);
    if (!round) {
      amp.forEach((partialAmp) => {
        nextAmp.push(
          (partialAmp && partialAmp + " ") + partialSelector
        );
      });
      return;
    } else if (round === 1) {
      amp.forEach((partialAmp) => {
        nextAmp.push(partialSelector.replace("&", partialAmp));
      });
      return;
    }
    let partialNextAmp = [
      partialSelector
    ];
    while (round--) {
      const nextPartialNextAmp = [];
      partialNextAmp.forEach((selectorItr) => {
        amp.forEach((partialAmp) => {
          nextPartialNextAmp.push(selectorItr.replace("&", partialAmp));
        });
      });
      partialNextAmp = nextPartialNextAmp;
    }
    partialNextAmp.forEach((part) => nextAmp.push(part));
  });
  return nextAmp;
}
function resolveSelector(amp, selector) {
  const nextAmp = [];
  selector.split(separatorRegex).forEach((partialSelector) => {
    amp.forEach((partialAmp) => {
      nextAmp.push((partialAmp && partialAmp + " ") + partialSelector);
    });
  });
  return nextAmp;
}
function parseSelectorPath(selectorPaths) {
  let amp = [""];
  selectorPaths.forEach((selector) => {
    selector = selector && selector.trim();
    if (!selector) {
      return;
    }
    if (selector.includes("&")) {
      amp = resolveSelectorWithAmp(amp, selector);
    } else {
      amp = resolveSelector(amp, selector);
    }
  });
  return amp.join(", ").replace(extraSpaceRegex, " ");
}
var separatorRegex, extraSpaceRegex;
var init_parse = __esm({
  "node_modules/css-render/esm/parse.js"() {
    separatorRegex = /\s*,(?![^(]*\))\s*/g;
    extraSpaceRegex = /\s+/g;
  }
});

// node_modules/css-render/esm/utils.js
function removeElement(el) {
  if (!el)
    return;
  const parentElement = el.parentElement;
  if (parentElement)
    parentElement.removeChild(el);
}
function queryElement(id) {
  return document.querySelector(`style[cssr-id="${id}"]`);
}
function createElement(id) {
  const el = document.createElement("style");
  el.setAttribute("cssr-id", id);
  return el;
}
function isMediaOrSupports(selector) {
  if (!selector)
    return false;
  return /^\s*@(s|m)/.test(selector);
}
var init_utils3 = __esm({
  "node_modules/css-render/esm/utils.js"() {
  }
});

// node_modules/css-render/esm/render.js
function kebabCase(pattern) {
  return pattern.replace(kebabRegex, (match) => "-" + match.toLowerCase());
}
function unwrapProperty(prop, indent = "  ") {
  if (typeof prop === "object" && prop !== null) {
    return " {\n" + Object.entries(prop).map((v) => {
      return indent + `  ${kebabCase(v[0])}: ${v[1]};`;
    }).join("\n") + "\n" + indent + "}";
  }
  return `: ${prop};`;
}
function unwrapProperties(props, instance, params2) {
  if (typeof props === "function") {
    return props({
      context: instance.context,
      props: params2
    });
  }
  return props;
}
function createStyle(selector, props, instance, params2) {
  if (!props)
    return "";
  const unwrappedProps = unwrapProperties(props, instance, params2);
  if (!unwrappedProps)
    return "";
  if (typeof unwrappedProps === "string") {
    return `${selector} {
${unwrappedProps}
}`;
  }
  const propertyNames = Object.keys(unwrappedProps);
  if (propertyNames.length === 0) {
    if (instance.config.keepEmptyBlock)
      return selector + " {\n}";
    return "";
  }
  const statements = selector ? [
    selector + " {"
  ] : [];
  propertyNames.forEach((propertyName) => {
    const property = unwrappedProps[propertyName];
    if (propertyName === "raw") {
      statements.push("\n" + property + "\n");
      return;
    }
    propertyName = kebabCase(propertyName);
    if (property !== null && property !== void 0) {
      statements.push(`  ${propertyName}${unwrapProperty(property)}`);
    }
  });
  if (selector) {
    statements.push("}");
  }
  return statements.join("\n");
}
function loopCNodeListWithCallback(children, options, callback) {
  if (!children)
    return;
  children.forEach((child) => {
    if (Array.isArray(child)) {
      loopCNodeListWithCallback(child, options, callback);
    } else if (typeof child === "function") {
      const grandChildren = child(options);
      if (Array.isArray(grandChildren)) {
        loopCNodeListWithCallback(grandChildren, options, callback);
      } else if (grandChildren) {
        callback(grandChildren);
      }
    } else if (child) {
      callback(child);
    }
  });
}
function traverseCNode(node, selectorPaths, styles, instance, params2, styleSheet) {
  const $ = node.$;
  let blockSelector = "";
  if (!$ || typeof $ === "string") {
    if (isMediaOrSupports($)) {
      blockSelector = $;
    } else {
      selectorPaths.push($);
    }
  } else if (typeof $ === "function") {
    const selector2 = $({
      context: instance.context,
      props: params2
    });
    if (isMediaOrSupports(selector2)) {
      blockSelector = selector2;
    } else {
      selectorPaths.push(selector2);
    }
  } else {
    if ($.before)
      $.before(instance.context);
    if (!$.$ || typeof $.$ === "string") {
      if (isMediaOrSupports($.$)) {
        blockSelector = $.$;
      } else {
        selectorPaths.push($.$);
      }
    } else if ($.$) {
      const selector2 = $.$({
        context: instance.context,
        props: params2
      });
      if (isMediaOrSupports(selector2)) {
        blockSelector = selector2;
      } else {
        selectorPaths.push(selector2);
      }
    }
  }
  const selector = parseSelectorPath(selectorPaths);
  const style = createStyle(selector, node.props, instance, params2);
  if (blockSelector) {
    styles.push(`${blockSelector} {`);
    if (styleSheet && style) {
      styleSheet.insertRule(`${blockSelector} {
${style}
}
`);
    }
  } else {
    if (styleSheet && style) {
      styleSheet.insertRule(style);
    }
    if (!styleSheet && style.length)
      styles.push(style);
  }
  if (node.children) {
    loopCNodeListWithCallback(node.children, {
      context: instance.context,
      props: params2
    }, (childNode) => {
      if (typeof childNode === "string") {
        const style2 = createStyle(selector, { raw: childNode }, instance, params2);
        if (styleSheet) {
          styleSheet.insertRule(style2);
        } else {
          styles.push(style2);
        }
      } else {
        traverseCNode(childNode, selectorPaths, styles, instance, params2, styleSheet);
      }
    });
  }
  selectorPaths.pop();
  if (blockSelector) {
    styles.push("}");
  }
  if ($ && $.after)
    $.after(instance.context);
}
function render(node, instance, props, insertRule = false) {
  const styles = [];
  traverseCNode(node, [], styles, instance, props, insertRule ? node.instance.__styleSheet : void 0);
  if (insertRule)
    return "";
  return styles.join("\n\n");
}
var kebabRegex;
var init_render = __esm({
  "node_modules/css-render/esm/render.js"() {
    init_parse();
    init_utils3();
    kebabRegex = /[A-Z]/g;
  }
});

// node_modules/css-render/esm/mount.js
function unmount(intance, node, id) {
  const { els } = node;
  if (id === void 0) {
    els.forEach(removeElement);
    node.els = [];
  } else {
    const target = queryElement(id);
    if (target && els.includes(target)) {
      removeElement(target);
      node.els = els.filter((el) => el !== target);
    }
  }
}
function addElementToList(els, target) {
  els.push(target);
}
function mount(instance, node, id, props, head, silent, force, anchorMetaName, ssrAdapter2) {
  if (silent && !ssrAdapter2) {
    if (id === void 0) {
      console.error("[css-render/mount]: `id` is required in `silent` mode.");
      return;
    }
    const cssrContext = window.__cssrContext;
    if (!cssrContext[id]) {
      cssrContext[id] = true;
      render(node, instance, props, silent);
    }
    return;
  }
  let style;
  if (id === void 0) {
    style = node.render(props);
    id = hash_browser_esm_default(style);
  }
  if (ssrAdapter2) {
    ssrAdapter2.adapter(id, style !== null && style !== void 0 ? style : node.render(props));
    return;
  }
  const queriedTarget = queryElement(id);
  if (queriedTarget !== null && !force) {
    return queriedTarget;
  }
  const target = queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : createElement(id);
  if (style === void 0)
    style = node.render(props);
  target.textContent = style;
  if (queriedTarget !== null)
    return queriedTarget;
  if (anchorMetaName) {
    const anchorMetaEl = document.head.querySelector(`meta[name="${anchorMetaName}"]`);
    if (anchorMetaEl) {
      document.head.insertBefore(target, anchorMetaEl);
      addElementToList(node.els, target);
      return target;
    }
  }
  if (head) {
    document.head.insertBefore(target, document.head.querySelector("style, link"));
  } else {
    document.head.appendChild(target);
  }
  addElementToList(node.els, target);
  return target;
}
var init_mount = __esm({
  "node_modules/css-render/esm/mount.js"() {
    init_hash();
    init_render();
    init_utils3();
    if (typeof window !== "undefined") {
      window.__cssrContext = {};
    }
  }
});

// node_modules/css-render/esm/c.js
function wrappedRender(props) {
  return render(this, this.instance, props);
}
function wrappedMount(options = {}) {
  const { id, ssr, props, head = false, silent = false, force = false, anchorMetaName } = options;
  const targetElement = mount(this.instance, this, id, props, head, silent, force, anchorMetaName, ssr);
  return targetElement;
}
function wrappedUnmount(options = {}) {
  const { id } = options;
  unmount(this.instance, this, id);
}
var createCNode, c;
var init_c = __esm({
  "node_modules/css-render/esm/c.js"() {
    init_render();
    init_mount();
    createCNode = function(instance, $, props, children) {
      return {
        instance,
        $,
        props,
        children,
        els: [],
        render: wrappedRender,
        mount: wrappedMount,
        unmount: wrappedUnmount
      };
    };
    c = function(instance, $, props, children) {
      if (Array.isArray($)) {
        return createCNode(instance, { $: null }, null, $);
      } else if (Array.isArray(props)) {
        return createCNode(instance, $, null, props);
      } else if (Array.isArray(children)) {
        return createCNode(instance, $, props, children);
      } else {
        return createCNode(instance, $, props, null);
      }
    };
  }
});

// node_modules/css-render/esm/CssRender.js
function CssRender(config = {}) {
  let styleSheet = null;
  const cssr = {
    c: (...args) => c(cssr, ...args),
    use: (plugin, ...args) => plugin.install(cssr, ...args),
    find: queryElement,
    context: {},
    config,
    get __styleSheet() {
      if (!styleSheet) {
        const style = document.createElement("style");
        document.head.appendChild(style);
        styleSheet = document.styleSheets[document.styleSheets.length - 1];
        return styleSheet;
      }
      return styleSheet;
    }
  };
  return cssr;
}
var init_CssRender = __esm({
  "node_modules/css-render/esm/CssRender.js"() {
    init_c();
    init_utils3();
  }
});

// node_modules/css-render/esm/types.js
var init_types = __esm({
  "node_modules/css-render/esm/types.js"() {
  }
});

// node_modules/css-render/esm/exists.js
function exists(id, ssr) {
  if (id === void 0)
    return false;
  if (ssr) {
    const { context: { ids } } = ssr;
    return ids.has(id);
  }
  return queryElement(id) !== null;
}
var init_exists = __esm({
  "node_modules/css-render/esm/exists.js"() {
    init_utils3();
  }
});

// node_modules/css-render/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  CssRender: () => CssRender,
  default: () => esm_default,
  exists: () => exists,
  hash: () => hash_browser_esm_default
});
var esm_default;
var init_esm = __esm({
  "node_modules/css-render/esm/index.js"() {
    init_CssRender();
    init_types();
    init_hash();
    init_exists();
    esm_default = CssRender;
  }
});

// node_modules/@css-render/vue3-ssr/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  setup: () => setup,
  useSsrAdapter: () => useSsrAdapter
});
function createStyleString(id, style) {
  return `<style cssr-id="${id}">
${style}
</style>`;
}
function ssrAdapter(id, style) {
  const ssrContext = inject(ssrContextKey, null);
  if (ssrContext === null) {
    console.error("[css-render/vue3-ssr]: no ssr context found.");
    return;
  }
  const { styles, ids } = ssrContext;
  if (ids.has(id))
    return;
  if (styles !== null) {
    ids.add(id);
    styles.push(createStyleString(id, style));
  }
}
function useSsrAdapter() {
  if (isBrowser2)
    return void 0;
  const context = inject(ssrContextKey, null);
  if (context === null)
    return void 0;
  return {
    adapter: ssrAdapter,
    context
  };
}
function setup(app) {
  const styles = [];
  const ssrContext = {
    styles,
    ids: /* @__PURE__ */ new Set()
  };
  app.provide(ssrContextKey, ssrContext);
  return {
    collect() {
      const res = styles.join("\n");
      styles.length = 0;
      return res;
    }
  };
}
var ssrContextKey, isBrowser2;
var init_esm2 = __esm({
  "node_modules/@css-render/vue3-ssr/esm/index.js"() {
    init_vue_runtime_esm_bundler();
    ssrContextKey = Symbol("@css-render/vue3-ssr");
    isBrowser2 = typeof document !== "undefined";
  }
});

// node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js
var resizeObservers;
var init_resizeObservers = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js"() {
    resizeObservers = [];
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js
var hasActiveObservations;
var init_hasActiveObservations = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js"() {
    init_resizeObservers();
    hasActiveObservations = function() {
      return resizeObservers.some(function(ro) {
        return ro.activeTargets.length > 0;
      });
    };
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js
var hasSkippedObservations;
var init_hasSkippedObservations = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js"() {
    init_resizeObservers();
    hasSkippedObservations = function() {
      return resizeObservers.some(function(ro) {
        return ro.skippedTargets.length > 0;
      });
    };
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js
var msg, deliverResizeLoopError;
var init_deliverResizeLoopError = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js"() {
    msg = "ResizeObserver loop completed with undelivered notifications.";
    deliverResizeLoopError = function() {
      var event;
      if (typeof ErrorEvent === "function") {
        event = new ErrorEvent("error", {
          message: msg
        });
      } else {
        event = document.createEvent("Event");
        event.initEvent("error", false, false);
        event.message = msg;
      }
      window.dispatchEvent(event);
    };
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js
var ResizeObserverBoxOptions;
var init_ResizeObserverBoxOptions = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js"() {
    (function(ResizeObserverBoxOptions2) {
      ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
      ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
      ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
    })(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
  }
});

// node_modules/@juggle/resize-observer/lib/utils/freeze.js
var freeze;
var init_freeze = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/freeze.js"() {
    freeze = function(obj) {
      return Object.freeze(obj);
    };
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js
var ResizeObserverSize;
var init_ResizeObserverSize = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js"() {
    init_freeze();
    ResizeObserverSize = function() {
      function ResizeObserverSize2(inlineSize, blockSize) {
        this.inlineSize = inlineSize;
        this.blockSize = blockSize;
        freeze(this);
      }
      return ResizeObserverSize2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js
var DOMRectReadOnly;
var init_DOMRectReadOnly = __esm({
  "node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js"() {
    init_freeze();
    DOMRectReadOnly = function() {
      function DOMRectReadOnly2(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.top = this.y;
        this.left = this.x;
        this.bottom = this.top + this.height;
        this.right = this.left + this.width;
        return freeze(this);
      }
      DOMRectReadOnly2.prototype.toJSON = function() {
        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
        return { x, y, top, right, bottom, left, width, height };
      };
      DOMRectReadOnly2.fromRect = function(rectangle) {
        return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
      };
      return DOMRectReadOnly2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/utils/element.js
var isSVG, isHidden, isElement, isReplacedElement;
var init_element = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/element.js"() {
    isSVG = function(target) {
      return target instanceof SVGElement && "getBBox" in target;
    };
    isHidden = function(target) {
      if (isSVG(target)) {
        var _a = target.getBBox(), width = _a.width, height = _a.height;
        return !width && !height;
      }
      var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
      return !(offsetWidth || offsetHeight || target.getClientRects().length);
    };
    isElement = function(obj) {
      var _a;
      if (obj instanceof Element) {
        return true;
      }
      var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
      return !!(scope && obj instanceof scope.Element);
    };
    isReplacedElement = function(target) {
      switch (target.tagName) {
        case "INPUT":
          if (target.type !== "image") {
            break;
          }
        case "VIDEO":
        case "AUDIO":
        case "EMBED":
        case "OBJECT":
        case "CANVAS":
        case "IFRAME":
        case "IMG":
          return true;
      }
      return false;
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/global.js
var global;
var init_global = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/global.js"() {
    global = typeof window !== "undefined" ? window : {};
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js
var cache, scrollRegexp, verticalRegexp, IE, parseDimension, size, zeroBoxes, calculateBoxSizes, calculateBoxSize;
var init_calculateBoxSize = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js"() {
    init_ResizeObserverBoxOptions();
    init_ResizeObserverSize();
    init_DOMRectReadOnly();
    init_element();
    init_freeze();
    init_global();
    cache = /* @__PURE__ */ new WeakMap();
    scrollRegexp = /auto|scroll/;
    verticalRegexp = /^tb|vertical/;
    IE = /msie|trident/i.test(global.navigator && global.navigator.userAgent);
    parseDimension = function(pixel) {
      return parseFloat(pixel || "0");
    };
    size = function(inlineSize, blockSize, switchSizes) {
      if (inlineSize === void 0) {
        inlineSize = 0;
      }
      if (blockSize === void 0) {
        blockSize = 0;
      }
      if (switchSizes === void 0) {
        switchSizes = false;
      }
      return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
    };
    zeroBoxes = freeze({
      devicePixelContentBoxSize: size(),
      borderBoxSize: size(),
      contentBoxSize: size(),
      contentRect: new DOMRectReadOnly(0, 0, 0, 0)
    });
    calculateBoxSizes = function(target, forceRecalculation) {
      if (forceRecalculation === void 0) {
        forceRecalculation = false;
      }
      if (cache.has(target) && !forceRecalculation) {
        return cache.get(target);
      }
      if (isHidden(target)) {
        cache.set(target, zeroBoxes);
        return zeroBoxes;
      }
      var cs = getComputedStyle(target);
      var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
      var removePadding = !IE && cs.boxSizing === "border-box";
      var switchSizes = verticalRegexp.test(cs.writingMode || "");
      var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
      var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
      var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
      var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
      var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
      var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
      var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
      var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
      var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
      var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
      var horizontalPadding = paddingLeft + paddingRight;
      var verticalPadding = paddingTop + paddingBottom;
      var horizontalBorderArea = borderLeft + borderRight;
      var verticalBorderArea = borderTop + borderBottom;
      var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
      var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
      var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
      var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
      var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
      var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
      var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
      var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
      var boxes = freeze({
        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
        contentBoxSize: size(contentWidth, contentHeight, switchSizes),
        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
      });
      cache.set(target, boxes);
      return boxes;
    };
    calculateBoxSize = function(target, observedBox, forceRecalculation) {
      var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
      switch (observedBox) {
        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
          return devicePixelContentBoxSize;
        case ResizeObserverBoxOptions.BORDER_BOX:
          return borderBoxSize;
        default:
          return contentBoxSize;
      }
    };
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js
var ResizeObserverEntry;
var init_ResizeObserverEntry = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js"() {
    init_calculateBoxSize();
    init_freeze();
    ResizeObserverEntry = function() {
      function ResizeObserverEntry2(target) {
        var boxes = calculateBoxSizes(target);
        this.target = target;
        this.contentRect = boxes.contentRect;
        this.borderBoxSize = freeze([boxes.borderBoxSize]);
        this.contentBoxSize = freeze([boxes.contentBoxSize]);
        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
      }
      return ResizeObserverEntry2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js
var calculateDepthForNode;
var init_calculateDepthForNode = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js"() {
    init_element();
    calculateDepthForNode = function(node) {
      if (isHidden(node)) {
        return Infinity;
      }
      var depth = 0;
      var parent = node.parentNode;
      while (parent) {
        depth += 1;
        parent = parent.parentNode;
      }
      return depth;
    };
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js
var broadcastActiveObservations;
var init_broadcastActiveObservations = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js"() {
    init_resizeObservers();
    init_ResizeObserverEntry();
    init_calculateDepthForNode();
    init_calculateBoxSize();
    broadcastActiveObservations = function() {
      var shallowestDepth = Infinity;
      var callbacks2 = [];
      resizeObservers.forEach(function processObserver(ro) {
        if (ro.activeTargets.length === 0) {
          return;
        }
        var entries = [];
        ro.activeTargets.forEach(function processTarget(ot) {
          var entry = new ResizeObserverEntry(ot.target);
          var targetDepth = calculateDepthForNode(ot.target);
          entries.push(entry);
          ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
          if (targetDepth < shallowestDepth) {
            shallowestDepth = targetDepth;
          }
        });
        callbacks2.push(function resizeObserverCallback() {
          ro.callback.call(ro.observer, entries, ro.observer);
        });
        ro.activeTargets.splice(0, ro.activeTargets.length);
      });
      for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
        var callback = callbacks_1[_i];
        callback();
      }
      return shallowestDepth;
    };
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js
var gatherActiveObservationsAtDepth;
var init_gatherActiveObservationsAtDepth = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js"() {
    init_resizeObservers();
    init_calculateDepthForNode();
    gatherActiveObservationsAtDepth = function(depth) {
      resizeObservers.forEach(function processObserver(ro) {
        ro.activeTargets.splice(0, ro.activeTargets.length);
        ro.skippedTargets.splice(0, ro.skippedTargets.length);
        ro.observationTargets.forEach(function processTarget(ot) {
          if (ot.isActive()) {
            if (calculateDepthForNode(ot.target) > depth) {
              ro.activeTargets.push(ot);
            } else {
              ro.skippedTargets.push(ot);
            }
          }
        });
      });
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/process.js
var process2;
var init_process = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/process.js"() {
    init_hasActiveObservations();
    init_hasSkippedObservations();
    init_deliverResizeLoopError();
    init_broadcastActiveObservations();
    init_gatherActiveObservationsAtDepth();
    process2 = function() {
      var depth = 0;
      gatherActiveObservationsAtDepth(depth);
      while (hasActiveObservations()) {
        depth = broadcastActiveObservations();
        gatherActiveObservationsAtDepth(depth);
      }
      if (hasSkippedObservations()) {
        deliverResizeLoopError();
      }
      return depth > 0;
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js
var trigger, callbacks, notify, queueMicroTask;
var init_queueMicroTask = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js"() {
    callbacks = [];
    notify = function() {
      return callbacks.splice(0).forEach(function(cb) {
        return cb();
      });
    };
    queueMicroTask = function(callback) {
      if (!trigger) {
        var toggle_1 = 0;
        var el_1 = document.createTextNode("");
        var config = { characterData: true };
        new MutationObserver(function() {
          return notify();
        }).observe(el_1, config);
        trigger = function() {
          el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
        };
      }
      callbacks.push(callback);
      trigger();
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js
var queueResizeObserver;
var init_queueResizeObserver = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js"() {
    init_queueMicroTask();
    queueResizeObserver = function(cb) {
      queueMicroTask(function ResizeObserver2() {
        requestAnimationFrame(cb);
      });
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/scheduler.js
var watching, isWatching, CATCH_PERIOD, observerConfig, events, time, scheduled, Scheduler, scheduler, updateCount;
var init_scheduler = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/scheduler.js"() {
    init_process();
    init_global();
    init_queueResizeObserver();
    watching = 0;
    isWatching = function() {
      return !!watching;
    };
    CATCH_PERIOD = 250;
    observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
    events = [
      "resize",
      "load",
      "transitionend",
      "animationend",
      "animationstart",
      "animationiteration",
      "keyup",
      "keydown",
      "mouseup",
      "mousedown",
      "mouseover",
      "mouseout",
      "blur",
      "focus"
    ];
    time = function(timeout) {
      if (timeout === void 0) {
        timeout = 0;
      }
      return Date.now() + timeout;
    };
    scheduled = false;
    Scheduler = function() {
      function Scheduler2() {
        var _this = this;
        this.stopped = true;
        this.listener = function() {
          return _this.schedule();
        };
      }
      Scheduler2.prototype.run = function(timeout) {
        var _this = this;
        if (timeout === void 0) {
          timeout = CATCH_PERIOD;
        }
        if (scheduled) {
          return;
        }
        scheduled = true;
        var until = time(timeout);
        queueResizeObserver(function() {
          var elementsHaveResized = false;
          try {
            elementsHaveResized = process2();
          } finally {
            scheduled = false;
            timeout = until - time();
            if (!isWatching()) {
              return;
            }
            if (elementsHaveResized) {
              _this.run(1e3);
            } else if (timeout > 0) {
              _this.run(timeout);
            } else {
              _this.start();
            }
          }
        });
      };
      Scheduler2.prototype.schedule = function() {
        this.stop();
        this.run();
      };
      Scheduler2.prototype.observe = function() {
        var _this = this;
        var cb = function() {
          return _this.observer && _this.observer.observe(document.body, observerConfig);
        };
        document.body ? cb() : global.addEventListener("DOMContentLoaded", cb);
      };
      Scheduler2.prototype.start = function() {
        var _this = this;
        if (this.stopped) {
          this.stopped = false;
          this.observer = new MutationObserver(this.listener);
          this.observe();
          events.forEach(function(name) {
            return global.addEventListener(name, _this.listener, true);
          });
        }
      };
      Scheduler2.prototype.stop = function() {
        var _this = this;
        if (!this.stopped) {
          this.observer && this.observer.disconnect();
          events.forEach(function(name) {
            return global.removeEventListener(name, _this.listener, true);
          });
          this.stopped = true;
        }
      };
      return Scheduler2;
    }();
    scheduler = new Scheduler();
    updateCount = function(n) {
      !watching && n > 0 && scheduler.start();
      watching += n;
      !watching && scheduler.stop();
    };
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObservation.js
var skipNotifyOnElement, ResizeObservation;
var init_ResizeObservation = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObservation.js"() {
    init_ResizeObserverBoxOptions();
    init_calculateBoxSize();
    init_element();
    skipNotifyOnElement = function(target) {
      return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
    };
    ResizeObservation = function() {
      function ResizeObservation2(target, observedBox) {
        this.target = target;
        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
        this.lastReportedSize = {
          inlineSize: 0,
          blockSize: 0
        };
      }
      ResizeObservation2.prototype.isActive = function() {
        var size2 = calculateBoxSize(this.target, this.observedBox, true);
        if (skipNotifyOnElement(this.target)) {
          this.lastReportedSize = size2;
        }
        if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
          return true;
        }
        return false;
      };
      return ResizeObservation2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js
var ResizeObserverDetail;
var init_ResizeObserverDetail = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js"() {
    ResizeObserverDetail = function() {
      function ResizeObserverDetail2(resizeObserver, callback) {
        this.activeTargets = [];
        this.skippedTargets = [];
        this.observationTargets = [];
        this.observer = resizeObserver;
        this.callback = callback;
      }
      return ResizeObserverDetail2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverController.js
var observerMap, getObservationIndex, ResizeObserverController;
var init_ResizeObserverController = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverController.js"() {
    init_scheduler();
    init_ResizeObservation();
    init_ResizeObserverDetail();
    init_resizeObservers();
    observerMap = /* @__PURE__ */ new WeakMap();
    getObservationIndex = function(observationTargets, target) {
      for (var i = 0; i < observationTargets.length; i += 1) {
        if (observationTargets[i].target === target) {
          return i;
        }
      }
      return -1;
    };
    ResizeObserverController = function() {
      function ResizeObserverController2() {
      }
      ResizeObserverController2.connect = function(resizeObserver, callback) {
        var detail = new ResizeObserverDetail(resizeObserver, callback);
        observerMap.set(resizeObserver, detail);
      };
      ResizeObserverController2.observe = function(resizeObserver, target, options) {
        var detail = observerMap.get(resizeObserver);
        var firstObservation = detail.observationTargets.length === 0;
        if (getObservationIndex(detail.observationTargets, target) < 0) {
          firstObservation && resizeObservers.push(detail);
          detail.observationTargets.push(new ResizeObservation(target, options && options.box));
          updateCount(1);
          scheduler.schedule();
        }
      };
      ResizeObserverController2.unobserve = function(resizeObserver, target) {
        var detail = observerMap.get(resizeObserver);
        var index = getObservationIndex(detail.observationTargets, target);
        var lastObservation = detail.observationTargets.length === 1;
        if (index >= 0) {
          lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
          detail.observationTargets.splice(index, 1);
          updateCount(-1);
        }
      };
      ResizeObserverController2.disconnect = function(resizeObserver) {
        var _this = this;
        var detail = observerMap.get(resizeObserver);
        detail.observationTargets.slice().forEach(function(ot) {
          return _this.unobserve(resizeObserver, ot.target);
        });
        detail.activeTargets.splice(0, detail.activeTargets.length);
      };
      return ResizeObserverController2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserver.js
var ResizeObserver;
var init_ResizeObserver = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserver.js"() {
    init_ResizeObserverController();
    init_element();
    ResizeObserver = function() {
      function ResizeObserver2(callback) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (typeof callback !== "function") {
          throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
        }
        ResizeObserverController.connect(this, callback);
      }
      ResizeObserver2.prototype.observe = function(target, options) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.observe(this, target, options);
      };
      ResizeObserver2.prototype.unobserve = function(target) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.unobserve(this, target);
      };
      ResizeObserver2.prototype.disconnect = function() {
        ResizeObserverController.disconnect(this);
      };
      ResizeObserver2.toString = function() {
        return "function ResizeObserver () { [polyfill code] }";
      };
      return ResizeObserver2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/exports/resize-observer.js
var resize_observer_exports = {};
__export(resize_observer_exports, {
  ResizeObserver: () => ResizeObserver,
  ResizeObserverEntry: () => ResizeObserverEntry,
  ResizeObserverSize: () => ResizeObserverSize
});
var init_resize_observer = __esm({
  "node_modules/@juggle/resize-observer/lib/exports/resize-observer.js"() {
    init_ResizeObserver();
    init_ResizeObserverEntry();
    init_ResizeObserverSize();
  }
});

export {
  beforeNextFrameOnce,
  getScrollParent,
  unwrapElement,
  happensIn,
  getPreciseEventTarget,
  parseResponsivePropValue,
  depx,
  pxfy,
  getMargin,
  getGap,
  hsl2hsv,
  hsv2hsl,
  hsv2rgb,
  rgb2hsv,
  rgb2hsl,
  hsl2rgb,
  hsla,
  hsva,
  rgba,
  composite,
  changeColor,
  scaleColor,
  toRgbString,
  toRgbaString,
  toHsvString,
  toHsvaString,
  toHslString,
  toHslaString,
  toHexaString,
  toHexString,
  createId,
  repeat,
  indexMap,
  es_exports2 as es_exports,
  init_es3 as init_es,
  hash_browser_esm_default,
  CssRender,
  exists,
  esm_exports,
  init_esm,
  useFalseUntilTruthy,
  use_memo_default,
  onFontsReady,
  on,
  off,
  init_es as init_es2,
  useClickPosition,
  useClicked,
  useOsTheme,
  useMergedState,
  isMounted,
  useCompitable,
  useIsIos,
  use_breakpoints_default,
  useKeyboard,
  es_exports as es_exports2,
  init_es2 as init_es3,
  useSsrAdapter,
  esm_exports2,
  init_esm2,
  ResizeObserver,
  resize_observer_exports,
  init_resize_observer
};
//# sourceMappingURL=chunk-TODGXHD4.js.map
